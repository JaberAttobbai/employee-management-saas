/**
 * ğŸ” Ù…ÙƒØªØ¨Ø© Ø¥Ø¯Ø§Ø±Ø© ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ±
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€:
 * - ØªÙˆÙ„ÙŠØ¯ ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙˆØ± Ù…Ø¤Ù‚ØªØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
 * - ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± (Hashing)
 * - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ±
 * - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
 */

import bcrypt from 'bcryptjs';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ² ØªÙˆÙ„ÙŠØ¯ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…Ø¤Ù‚ØªØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ÙŠÙˆÙ„Ù‘Ø¯ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…Ø¤Ù‚ØªØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù‚ÙˆÙŠØ©
 * 
 * @param length - Ø·ÙˆÙ„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (Ø§ÙØªØ±Ø§Ø¶ÙŠ: 12)
 * @returns ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
 * 
 * @example
 * const tempPassword = generateTemporaryPassword();
 * // Ø§Ù„Ù†ØªÙŠØ¬Ø©: "K7#mP9@qL2nX"
 */
export function generateTemporaryPassword(length: number = 12): string {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ“š Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz';
    const numbers = '0123456789';
    const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ø­Ø±Ù ÙˆØ§Ø­Ø¯ Ù…Ù† ÙƒÙ„ Ù†ÙˆØ¹
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Ù‡Ø°Ø§ ÙŠØ¶Ù…Ù† Ø£Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ© ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø±ÙØ¶Ù‡Ø§
    const password: string[] = [
        uppercaseLetters[Math.floor(Math.random() * uppercaseLetters.length)], // Ø­Ø±Ù ÙƒØ¨ÙŠØ± 1
        lowercaseLetters[Math.floor(Math.random() * lowercaseLetters.length)], // Ø­Ø±Ù ØµØºÙŠØ± 1
        numbers[Math.floor(Math.random() * numbers.length)],                   // Ø±Ù‚Ù… 1
        specialChars[Math.floor(Math.random() * specialChars.length)]         // Ø±Ù…Ø² Ø®Ø§Øµ 1
    ];

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ”€ Ù…Ù„Ø¡ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø­Ø±ÙˆÙ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const allChars = uppercaseLetters + lowercaseLetters + numbers + specialChars;

    for (let i = password.length; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * allChars.length);
        password.push(allChars[randomIndex]);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ² Ø®Ù„Ø· Ø§Ù„Ø­Ø±ÙˆÙ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Fisher-Yates Shuffle Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙˆØ²ÙŠØ¹ Ø¹Ø§Ø¯Ù„
    for (let i = password.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [password[i], password[j]] = [password[j], password[i]]; // Swap
    }

    return password.join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”’ ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (Hashing)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ÙŠØ´ÙÙ‘Ø± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… bcrypt
 * 
 * @param password - ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø£ØµÙ„ÙŠØ© (Ù†Øµ ØµØ±ÙŠØ­)
 * @returns ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø´ÙØ±Ø© (Hash)
 * 
 * @example
 * const hash = await hashPassword("MyPassword123");
 * // Ø§Ù„Ù†ØªÙŠØ¬Ø©: "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy"
 */
export async function hashPassword(password: string): Promise<string> {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ§‚ Salt Rounds = 10
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 10 Ø¬ÙˆÙ„Ø§Øª ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø³Ø±Ø¹Ø©:
    // - Ø£Ù‚Ù„ Ù…Ù† 10 = Ø¶Ø¹ÙŠÙ (Ø³Ù‡Ù„ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚)
    // - 10 = Ù…Ø«Ø§Ù„ÙŠ (Ù…Ø¹ÙŠØ§Ø± ØµÙ†Ø§Ø¹ÙŠ)
    // - Ø£ÙƒØ«Ø± Ù…Ù† 12 = Ø¨Ø·ÙŠØ¡ Ø¬Ø¯Ø§Ù‹
    const saltRounds = 10;

    // bcrypt ÙŠÙ‚ÙˆÙ… Ø¨Ù€:
    // 1. ØªÙˆÙ„ÙŠØ¯ salt Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
    // 2. Ø¯Ù…Ø¬ salt Ù…Ø¹ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    // 3. ØªØ·Ø¨ÙŠÙ‚ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„ØªØ´ÙÙŠØ± 2^10 Ù…Ø±Ø©
    const hash = await bcrypt.hash(password, saltRounds);

    return hash;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ÙŠØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
 * 
 * @param plainPassword - ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…ÙØ¯Ø®Ù„Ø© (Ù†Øµ ØµØ±ÙŠØ­)
 * @param hashedPassword - ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø´ÙØ±Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 * @returns true Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ØªØ·Ø§Ø¨Ù‚Ø©ØŒ false Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø®Ø§Ø·Ø¦Ø©
 * 
 * @example
 * const isValid = await verifyPassword("MyPassword123", storedHash);
 * if (isValid) {
 *   // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„
 * }
 */
export async function verifyPassword(
    plainPassword: string,
    hashedPassword: string
): Promise<boolean> {
    // bcrypt.compare ØªÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± ÙˆØªÙ‚Ø§Ø±Ù†:
    // 1. ØªØ³ØªØ®Ø±Ø¬ salt Ù…Ù† hashedPassword
    // 2. ØªØ´ÙØ± plainPassword Ø¨Ù†ÙØ³ salt
    // 3. ØªÙ‚Ø§Ø±Ù† Ø§Ù„Ù†ØªÙŠØ¬ØªÙŠÙ†
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);

    return isMatch;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ª Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
 */
export interface PasswordStrengthResult {
    isValid: boolean;       // Ù‡Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©ØŸ
    errors: string[];       // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    strength: 'weak' | 'medium' | 'strong'; // Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
}

/**
 * ÙŠØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
 * 
 * @param password - ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§
 * @returns Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
 * 
 * @example
 * const result = validatePasswordStrength("abc123");
 * if (!result.isValid) {
 *   console.log(result.errors); // ["ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹", ...]
 * }
 */
export function validatePasswordStrength(password: string): PasswordStrengthResult {
    const errors: string[] = [];
    let strength: 'weak' | 'medium' | 'strong' = 'weak';

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // 1ï¸âƒ£ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ø£Ø¯Ù†Ù‰: 8 Ø£Ø­Ø±Ù
    if (password.length < 8) {
        errors.push('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 8 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
    }

    // 2ï¸âƒ£ ÙˆØ¬ÙˆØ¯ Ø­Ø±Ù ÙƒØ¨ÙŠØ± (A-Z)
    if (!/[A-Z]/.test(password)) {
        errors.push('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ø±Ù ÙƒØ¨ÙŠØ± ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
    }

    // 3ï¸âƒ£ ÙˆØ¬ÙˆØ¯ Ø­Ø±Ù ØµØºÙŠØ± (a-z)
    if (!/[a-z]/.test(password)) {
        errors.push('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ø±Ù ØµØºÙŠØ± ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
    }

    // 4ï¸âƒ£ ÙˆØ¬ÙˆØ¯ Ø±Ù‚Ù… (0-9)
    if (!/[0-9]/.test(password)) {
        errors.push('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
    }

    // 5ï¸âƒ£ ÙˆØ¬ÙˆØ¯ Ø±Ù…Ø² Ø®Ø§Øµ (!@#$%...)
    if (!/[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]/.test(password)) {
        errors.push('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù…Ø² Ø®Ø§Øµ ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ (!@#$%...)');
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ“Š Ø­Ø³Ø§Ø¨ Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasNumber = /[0-9]/.test(password);
    const hasSpecial = /[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]/.test(password);
    const isLongEnough = password.length >= 8;

    const criteriasMet = [
        hasUppercase,
        hasLowercase,
        hasNumber,
        hasSpecial,
        isLongEnough
    ].filter(Boolean).length;

    if (criteriasMet === 5 && password.length >= 12) {
        strength = 'strong';
    } else if (criteriasMet >= 4) {
        strength = 'medium';
    } else {
        strength = 'weak';
    }

    return {
        isValid: errors.length === 0,
        errors,
        strength
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§ª Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø± (Dev Only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ÙŠÙˆÙ„Ù‘Ø¯ 5 ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙˆØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
 * ğŸš¨ Ù„Ù„ØªØ·ÙˆÙŠØ± ÙÙ‚Ø· - Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… ÙÙŠ Production!
 */
export function generateMultiplePasswords(count: number = 5): string[] {
    return Array.from({ length: count }, () => generateTemporaryPassword());
}
